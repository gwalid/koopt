<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            width: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <script id="vertexShader" type="x-shader/x-vertex">
        uniform sampler2D bumpTexture;
        uniform float bumpScale;
        
        varying float vAmount;
        varying vec2 vUV;
        
        void main() 
        { 
            vUV = uv;
            vec4 bumpData = texture2D( bumpTexture, uv );
            
            vAmount = bumpData.r; // assuming map is grayscale it doesn't matter if you use r, g, or b.
            
            // move the position along the normal
            vec3 newPosition = position + normal * bumpScale * vAmount;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
        }
    </script>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.module.js';
        import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r113/examples/jsm/controls/OrbitControls.js';
        function main() {
            const canvas = document.querySelector('#c');
            const renderer = new THREE.WebGLRenderer({ canvas });

            const fov = 70;
            const aspect = 2;  // the canvas default
            const near = 0.1;
            const far = 500;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 3;

            const controls = new OrbitControls(camera, canvas);
            controls.target.set(0, 5, 0);
            controls.update();
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            {
                const color = 0xFFFFFF;
                const intensity = 1;
                /*const light = new THREE.DirectionalLight(color, intensity);
                light.position.set(-1, 2, 4);
                scene.add(light);*/
                var ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );

                var light = new THREE.DirectionalLight(0xefefff, 1.5);
                light.position.set(1, 1, 1).normalize();
                scene.add(light);

                var light = new THREE.DirectionalLight(0xffefef, 1.5);
                light.position.set(- 1, 2, - 1).normalize();
                scene.add(light);
                var light = new THREE.DirectionalLight(0xffefef, 1.);
                light.position.set(- 1, -1, - 1).normalize();
                scene.add(light);
            }

            /*bumpmap*/

            // texture used to generate "bumpiness"
            const loader2 = new THREE.TextureLoader();
            var bumpTexture = loader2.load( 'https://stemkoski.github.io/Three.js/images/heightmap.png' );
            bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping; 
            // magnitude of normal displacement
            var bumpScale   = 10.0;
            
            
            var customUniforms = {
            bumpTexture:	{ type: "t", value: bumpTexture },
            bumpScale:	    { type: "f", value: bumpScale }
            };

            var customMaterial = new THREE.ShaderMaterial( 
            {
                uniforms: customUniforms,
                vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
                //fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                 side: THREE.DoubleSide
            }   );

            var planeGeo2 = new THREE.PlaneGeometry( 50, 50, 100, 100 );
            var plane = new THREE.Mesh(	planeGeo2, customMaterial );
            plane.rotation.x = Math.PI ;
            plane.position.y = 0;
            scene.add( plane );



            /*plane*/
            const planeSize = 140;

            const loader = new THREE.TextureLoader();
            const texture = loader.load('js/Fresh-Water-Texture.png');
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter;
            const repeats = planeSize / 2;
            texture.repeat.set(repeats, repeats);

            const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide,
            });
            const mesh = new THREE.Mesh(planeGeo, planeMat);
            scene.add(mesh);
            var axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );
            /*plane*/

            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
            const material = new THREE.MeshPhongMaterial({ color: 0x44aa88 });  // greenish blue

            function makeInstance(geometry, color, x) {
                const material = new THREE.MeshPhongMaterial({ color });

                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);

                cube.position.x = x;
                cube.position.y = 3
                cube.position.z = 1/2;
                return cube;
            }


            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize;
            }
            function render(time) {
                time *= 0.001;  // convert time to seconds

                if (resizeRendererToDisplaySize(renderer)) {
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }

                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);

                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        main();

    </script>



    <canvas id="c"></canvas>
</body>

</html>