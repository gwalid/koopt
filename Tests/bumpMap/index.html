<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            width: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
</head>

<body>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.module.js';
        import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r113/examples/jsm/controls/OrbitControls.js';
        import { SubdivisionModifier } from 'https://threejsfundamentals.org/threejs/resources/threejs/r113/examples/jsm/modifiers/SubdivisionModifier.js';
        import { SimplifyModifier } from 'https://threejsfundamentals.org/threejs/resources/threejs/r113/examples/jsm/modifiers/SimplifyModifier.js';
        function main() {
            const canvas = document.querySelector('#c');
            const renderer = new THREE.WebGLRenderer({ canvas });

            const fov = 70;
            const aspect = 2;  // the canvas default
            const near = 0.1;
            const far = 500;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 3;

            const controls = new OrbitControls(camera, canvas);
            controls.target.set(0, 5, 0);
            controls.update();
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            {
                const color = 0xFFFFFF;
                const intensity = 1;
                /*const light = new THREE.DirectionalLight(color, intensity);
                light.position.set(-1, 2, 4);
                scene.add(light);*/
                var ambient = new THREE.AmbientLight(0x444444);
                scene.add(ambient);

                var light = new THREE.DirectionalLight(0xefefff, 1.5);
                light.position.set(1, 1, 1).normalize();
                scene.add(light);

                var light = new THREE.DirectionalLight(0xffefef, 1.5);
                light.position.set(- 1, 2, - 1).normalize();
                scene.add(light);
                var light = new THREE.DirectionalLight(0xffefef, 1.);
                light.position.set(- 1, -1, - 1).normalize();
                scene.add(light);
            }

            function chargeMap(src) {
                var img = new Image(128, 128);
                var loaded = false;

                var cnvs = document.createElement("canvas");
                cnvs.id="mine"
                var ctx = cnvs.getContext('2d');
                img.onload = new function () {
                    loaded = true;

                    cnvs.width = img.width;
                    console.log(img.width)
                    console.log("loaded")
                }
                img.src = "hmap3.png";

                ctx.height = img.height;
                ctx.drawImage(img, 0, 0, img.width, img.height);
                document.body.appendChild(cnvs);
                //console.log(ctx.getImageData(0,0,img.width,img.height).data)
                while (!loaded) {
                    console.log("charge " + loaded);
                }
                // Get the pixels by draw the image onto a canvas. From the canvas get the Pixel (R,G,B,A)
                function getTerrainPixelData() {

                    //while(!loaded) window.setTimeout(()=>{console.log(loaded)},100)
                    cnvs.width = img.width;
                    cnvs.height = img.height;
                    cnvs.getContext('2d').drawImage(img, 0, 0, img.width, img.height);

                    var data = cnvs.getContext('2d').getImageData(0, 0, img.height, img.width).data;
                    var normPixels = []
                    for (var i = 0, n = data.length; i < n; i += 4) {
                        // get the average value of R, G and B.
                        normPixels.push((data[i] + data[i + 1] + data[i + 2]) / 3); //Essentially render image black and white
                    }

                    return normPixels;
                }
                var ddd = getTerrainPixelData();
                for(var i = 0 ; i < ddd.length; i++){
                    if(ddd[i] != 0){
                        console.log("diffenret")
                    }
                }
            }
            chargeMap("hmap3.png")

            /*
            var data = ctx.getImageData(0, 0, img.width, img.height).data;
            var terrain = []
            for (var i = 0, n = data.length; i < n; i += 4) {
                // get the average value of R, G and B.
                terrain.push((data[i] + data[i + 1] + data[i + 2]) / 3); //Essentially render image black and white
            }
            var numSegments = img.width - 1; //Equal to number of image pixels - 1

            var geometriePlan = new THREE.PlaneGeometry(taillePlan, taillePlan, numSegments, numSegments);//400*400 bcp...
            for (var i = 0, l = geometriePlan.vertices.length; i < l; i++) // For each vertex
            {
                var terrainValue = terrain[i] / 255;
                geometriePlan.vertices[i].z += terrainValue * 800; // Define height of vertices against image pixel data
            }
            */

            var taillePlan = 100;
            var geometriePlan = new THREE.PlaneGeometry(taillePlan, taillePlan, 100, 100);
            const matSol = new THREE.MeshPhongMaterial({
                color: 0x44aa88,
                side: THREE.DoubleSide,
            });

            var plane = new THREE.Mesh(geometriePlan, matSol);
            //PASTEEEEEEEEEEEEEEEEEEEE




            plane.position.y = 0;
            plane.position.z = -0.3;

            var modifier = new SimplifyModifier();
            var simplified = plane.clone();
            simplified.material = plane.material.clone();
            simplified.material.flatShading = true;
            var count = Math.floor(simplified.geometry.vertices.length * 0.8); // number of vertices to remove
            simplified.geometry = modifier.modify(simplified.geometry, count);

            simplified.geometry.verticesNeedUpdate = true;
            scene.add(simplified);




            //scene.add(plane);



            //img.src = "hmap3.png";

            /*plane*/
            const planeSize = 300;

            const loader = new THREE.TextureLoader();
            const texture = loader.load('js/Fresh-Water-Texture.png');
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter;
            const repeats = planeSize / 2;
            texture.repeat.set(repeats, repeats);

            const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
            var dmap = new THREE.TextureLoader().load("hmap5.png");
            const planeMat = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide,
                displacementMap: dmap,
            });
            const mesh = new THREE.Mesh(planeGeo, planeMat);
            scene.add(mesh);
            var axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            /*plane*/

            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
            const material = new THREE.MeshPhongMaterial({ color: 0x44aa88, flatshading: true });  // greenish blue

            function makeInstance(geometry, color, x) {
                const material = new THREE.MeshPhongMaterial({ color });

                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);

                cube.position.x = x;
                cube.position.y = 3
                cube.position.z = 1 / 2;
                return cube;
            }


            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize;
            }
            function render(time) {
                time *= 0.001;  // convert time to seconds

                if (resizeRendererToDisplaySize(renderer)) {
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }

                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);

                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        main();

    </script>



    <canvas id="c"></canvas>
</body>

</html>